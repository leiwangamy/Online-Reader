import os
import asyncio
from flask import Flask, render_template, request
from docx import Document
from pydub import AudioSegment
from pydub.effects import speedup
import edge_tts
from edge_tts.exceptions import NoAudioReceived

app = Flask(__name__)
UPLOAD_FOLDER = "uploads"
OUTPUT_FILE = "static/output.mp3"
DEFAULT_MUSIC = "static/music/background.mp3"
MAX_LENGTH = 10000

os.makedirs(UPLOAD_FOLDER, exist_ok=True)

VOICE_MAP = {
    "zh_female": "zh-CN-XiaoxiaoNeural",
    "zh_male": "zh-CN-YunxiNeural",
    "zh-hk_female": "zh-HK-HiuMaanNeural",
    "zh-hk_male": "zh-HK-WanLungNeural",
    "en_female": "en-US-AriaNeural",
    "en_male": "en-US-GuyNeural",
    "ja_female": "ja-JP-NanamiNeural",
    "ja_male": "ja-JP-KeitaNeural",
    "fr_female": "fr-FR-DeniseNeural",
    "fr_male": "fr-FR-HenriNeural"
}

def extract_text(filepath):
    if filepath.endswith(".txt"):
        try:
            with open(filepath, encoding="utf-8") as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                with open(filepath, encoding="gbk", errors="ignore") as f:
                    return f.read()
            except Exception as e:
                print(f"读取 txt 文件失败: {e}")
                return ""
    elif filepath.endswith(".docx"):
        try:
            doc = Document(filepath)
            return "\n".join(p.text for p in doc.paragraphs if p.text.strip())
        except Exception as e:
            print(f"读取 docx 文件失败: {e}")
            return ""
    return ""

async def generate_speech(text, voice_id, out_path, speed):
    communicate = edge_tts.Communicate(
        text,
        voice=voice_id,
        rate=f"{float(speed) * 100 - 100:+.0f}%"
    )
    await communicate.save(out_path)

def mix_music(voice_path, music_path, speed, include_music, volume_adjust):
    if include_music and os.path.exists(music_path):
        voice = AudioSegment.from_file(voice_path)
        music = AudioSegment.from_file(music_path)
        music = music - int(volume_adjust)
        try:
            if float(speed) != 1.0:
                music = speedup(music, playback_speed=float(speed))
        except Exception as e:
            print(f"背景音乐加速失败：{e}")
        music = music[:len(voice)]
        combined = music.overlay(voice)
        combined.export(voice_path, format="mp3")

@app.route("/", methods=["GET", "POST"])
def index():
    download_link = None
    error = None

    if os.path.exists(OUTPUT_FILE):
        os.remove(OUTPUT_FILE)
    for f in os.listdir(UPLOAD_FOLDER):
        os.remove(os.path.join(UPLOAD_FOLDER, f))

    if request.method == "POST":
        try:
            text = request.form.get("typed_text", "").strip()
            voice_key = request.form.get("voice_gender", "zh_female")
            music_on = request.form.get("music") == "on"
            music_speed = request.form.get("speed", "1.0")
            voice_speed = request.form.get("voice_speed", "1.0")
            music_volume = request.form.get("music_volume", "15")
            music_upload = request.files.get("bgmusicfile")

            if not text:
                file = request.files.get("textfile")
                if file and file.filename:
                    ext = file.filename.rsplit(".", 1)[-1].lower()
                    input_path = os.path.join(UPLOAD_FOLDER, f"input.{ext}")
                    file.save(input_path)
                    text = extract_text(input_path)

            if not text:
                error = "⚠️ 输入内容为空，请填写或上传文本。\n⚠️ No text found. Please enter or upload your content."
                return render_template("index.html", error=error)

            if len(text) > MAX_LENGTH:
                error = "⚠️ 文本过长，请限制在 10,000 字以内。\n⚠️ Text too long. Please limit to 10,000 characters."
                return render_template("index.html", error=error)

            voice_id = VOICE_MAP.get(voice_key)
            if not voice_id:
                error = "⚠️ 当前版本暂不支持所选语言或语音。\n⚠️ The selected voice is not supported."
                return render_template("index.html", error=error)

            bg_music_path = DEFAULT_MUSIC
            if music_upload and music_upload.filename:
                custom_path = os.path.join(UPLOAD_FOLDER, "custom_music.mp3")
                music_upload.save(custom_path)
                bg_music_path = custom_path

            asyncio.run(generate_speech(text, voice_id, OUTPUT_FILE, voice_speed))
            mix_music(OUTPUT_FILE, bg_music_path, music_speed, music_on, music_volume)

            download_link = OUTPUT_FILE

        except NoAudioReceived:
            error = "⚠️ 无法生成语音。请检查输入内容和语言设置是否正确。\n⚠️ No audio was generated. Please check your input and voice selection."
        except Exception as e:
            error = f"⚠️ 出现未知错误，请稍后再试。\n⚠️ An unexpected error occurred. {str(e)}"

    return render_template("index.html", download_link=download_link, error=error)

@app.route("/files")  # ✅ 插入在这里
def list_files():
    files = [
        f for f in os.listdir("static")
        if f.startswith("output_") and f.endswith(".mp3")
    ]
    return "<h3>当前已生成的 MP3 文件：</h3>" + "<br>".join(files)

clean_old_files_periodically("static", prefix="output_", age_limit=600, interval=300)

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8080, debug=True)
